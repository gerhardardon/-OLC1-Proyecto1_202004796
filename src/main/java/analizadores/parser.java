
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package analizadores;

import java_cup.runtime.*;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java_cup.runtime.XMLElement;
import proyect1.menu;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\034\000\002\002\004\000\002\002\003\000\002\003" +
    "\005\000\002\004\004\000\002\004\004\000\002\004\004" +
    "\000\002\004\004\000\002\004\004\000\002\004\004\000" +
    "\002\004\004\000\002\004\003\000\002\004\003\000\002" +
    "\004\003\000\002\004\003\000\002\004\003\000\002\004" +
    "\003\000\002\005\010\000\002\011\006\000\002\012\005" +
    "\000\002\012\005\000\002\012\004\000\002\012\004\000" +
    "\002\012\004\000\002\012\003\000\002\012\003\000\002" +
    "\012\003\000\002\007\004\000\002\010\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\063\000\004\004\004\001\002\000\014\007\014\016" +
    "\015\022\013\027\021\030\020\001\002\000\004\002\000" +
    "\001\002\000\004\002\007\001\002\000\004\002\001\001" +
    "\002\000\020\003\ufff7\005\ufff7\007\ufff7\016\ufff7\022\ufff7" +
    "\027\ufff7\030\ufff7\001\002\000\020\003\040\005\041\007" +
    "\014\016\015\022\035\027\043\030\042\001\002\000\020" +
    "\003\ufff4\005\ufff4\007\ufff4\016\ufff4\022\ufff4\027\ufff4\030" +
    "\ufff4\001\002\000\004\006\030\001\002\000\004\007\027" +
    "\001\002\000\004\006\022\001\002\000\020\003\ufff5\005" +
    "\ufff5\007\ufff5\016\ufff5\022\ufff5\027\ufff5\030\ufff5\001\002" +
    "\000\020\003\ufff6\005\ufff6\007\ufff6\016\ufff6\022\ufff6\027" +
    "\ufff6\030\ufff6\001\002\000\020\003\ufff2\005\ufff2\007\ufff2" +
    "\016\ufff2\022\ufff2\027\ufff2\030\ufff2\001\002\000\020\003" +
    "\ufff3\005\ufff3\007\ufff3\016\ufff3\022\ufff3\027\ufff3\030\ufff3" +
    "\001\002\000\004\022\023\001\002\000\004\020\024\001" +
    "\002\000\004\021\025\001\002\000\004\010\026\001\002" +
    "\000\020\003\ufff1\005\ufff1\007\ufff1\016\ufff1\022\ufff1\027" +
    "\ufff1\030\ufff1\001\002\000\020\003\uffe7\005\uffe7\007\uffe7" +
    "\016\uffe7\022\uffe7\027\uffe7\030\uffe7\001\002\000\004\026" +
    "\031\001\002\000\004\010\032\001\002\000\020\003\uffe6" +
    "\005\uffe6\007\uffe6\016\uffe6\022\uffe6\027\uffe6\030\uffe6\001" +
    "\002\000\020\003\ufffe\005\ufffe\007\ufffe\016\ufffe\022\ufffe" +
    "\027\ufffe\030\ufffe\001\002\000\020\003\ufff9\005\ufff9\007" +
    "\ufff9\016\ufff9\022\ufff9\027\ufff9\030\ufff9\001\002\000\006" +
    "\006\030\020\044\001\002\000\020\003\ufffb\005\ufffb\007" +
    "\ufffb\016\ufffb\022\ufffb\027\ufffb\030\ufffb\001\002\000\020" +
    "\003\ufffa\005\ufffa\007\ufffa\016\ufffa\022\ufffa\027\ufffa\030" +
    "\ufffa\001\002\000\020\003\ufff8\005\ufff8\007\ufff8\016\ufff8" +
    "\022\ufff8\027\ufff8\030\ufff8\001\002\000\004\002\uffff\001" +
    "\002\000\020\003\ufffc\005\ufffc\007\ufffc\016\ufffc\022\ufffc" +
    "\027\ufffc\030\ufffc\001\002\000\020\003\ufffd\005\ufffd\007" +
    "\ufffd\016\ufffd\022\ufffd\027\ufffd\030\ufffd\001\002\000\022" +
    "\011\051\012\050\013\053\014\046\015\052\023\054\024" +
    "\055\025\045\001\002\000\024\010\uffe8\011\uffe8\012\uffe8" +
    "\013\uffe8\014\uffe8\015\uffe8\023\uffe8\024\uffe8\025\uffe8\001" +
    "\002\000\022\011\051\012\050\013\053\014\046\015\052" +
    "\023\054\024\055\025\045\001\002\000\004\010\064\001" +
    "\002\000\022\011\051\012\050\013\053\014\046\015\052" +
    "\023\054\024\055\025\045\001\002\000\022\011\051\012" +
    "\050\013\053\014\046\015\052\023\054\024\055\025\045" +
    "\001\002\000\022\011\051\012\050\013\053\014\046\015" +
    "\052\023\054\024\055\025\045\001\002\000\022\011\051" +
    "\012\050\013\053\014\046\015\052\023\054\024\055\025" +
    "\045\001\002\000\024\010\uffea\011\uffea\012\uffea\013\uffea" +
    "\014\uffea\015\uffea\023\uffea\024\uffea\025\uffea\001\002\000" +
    "\024\010\uffe9\011\uffe9\012\uffe9\013\uffe9\014\uffe9\015\uffe9" +
    "\023\uffe9\024\uffe9\025\uffe9\001\002\000\024\010\uffed\011" +
    "\uffed\012\uffed\013\uffed\014\uffed\015\uffed\023\uffed\024\uffed" +
    "\025\uffed\001\002\000\024\010\uffeb\011\uffeb\012\uffeb\013" +
    "\uffeb\014\uffeb\015\uffeb\023\uffeb\024\uffeb\025\uffeb\001\002" +
    "\000\022\011\051\012\050\013\053\014\046\015\052\023" +
    "\054\024\055\025\045\001\002\000\024\010\uffef\011\uffef" +
    "\012\uffef\013\uffef\014\uffef\015\uffef\023\uffef\024\uffef\025" +
    "\uffef\001\002\000\022\011\051\012\050\013\053\014\046" +
    "\015\052\023\054\024\055\025\045\001\002\000\024\010" +
    "\uffee\011\uffee\012\uffee\013\uffee\014\uffee\015\uffee\023\uffee" +
    "\024\uffee\025\uffee\001\002\000\020\003\ufff0\005\ufff0\007" +
    "\ufff0\016\ufff0\022\ufff0\027\ufff0\030\ufff0\001\002\000\024" +
    "\010\uffec\011\uffec\012\uffec\013\uffec\014\uffec\015\uffec\023" +
    "\uffec\024\uffec\025\uffec\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\063\000\006\002\005\003\004\001\001\000\014\004" +
    "\010\005\007\006\016\007\015\010\011\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\005\032\007\036\010\033\011\035\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\012\046\001\001\000\002\001\001\000\004\012" +
    "\064\001\001\000\002\001\001\000\004\012\061\001\001" +
    "\000\004\012\057\001\001\000\004\012\056\001\001\000" +
    "\004\012\055\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\012\060\001" +
    "\001\000\002\001\001\000\004\012\062\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  
    
    
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     *
     */
    public void syntax_error(Symbol s) {
        System.out.println("Error Sintáctico en la Línea " + (s.left)
                + " Columna " + s.right + ". No se esperaba este componente: " + s.value + ".");
                listaErrores error = new listaErrores(s.value.toString(),s.right,s.left,"sintactico");
                menu.err.add(error);
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico en el
     * que ya no es posible una recuperación de errores.
     *
     */
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.out.println("Error síntactico irrecuperable en la Línea "
                + (s.left) + " Columna " + s.right + ". Componente " + s.value
                + " no reconocido.");
        listaErrores error = new listaErrores(s.value.toString(),s.right,s.left,"sintactico");
        menu.err.add(error);
    }

    //ARRAYS UTILES PARA TRANSICIONES-------------------------------------------
    public static ArrayList<String> arrayId = new ArrayList<String>(); //sym
    public static ArrayList<String> sigposEvaluar = new ArrayList<String>(); //sigpos a evaluar
    public static HashMap<String, String> hashEstados = new HashMap<String, String>();// sigpos -> S
    public static HashMap<String, String> hashAux = new HashMap<String, String>();// numHoja -> sigpos
    public static int numEstado = 0;
    public static ListaSimple ls =new ListaSimple();

    /* DICCIONARIO
        arrayId.get(Integer.parseInt(primero)-1) obtener sym desde un numHoja de hash
        
     */
    public static void transiciones(String sigpos, int estadoEval,String nombre) { //PARAMETRO QUE INGRESA LAS SIGPOS.
        String firsts = sigpos;
        String[] primeros = firsts.split(","); //obtenemos los primeros del arbol
        for (String x : primeros) {//llenamos aux ---------------------------------------------
            hashAux.put(x, tablaSiguientes.get(x));
        }

        for (String i : hashAux.keySet()) { //buscar duplicados
            for (String j : hashAux.keySet()) { //buscar duplicados
                if (i == j) {

                } else {
                    String sym1 = arrayId.get(Integer.parseInt(i) - 1);
                    String sym2 = arrayId.get(Integer.parseInt(j) - 1);
                    //System.out.println("sym1:" + sym1 + " sym2:" + sym2);

                    if (sym1.equals(sym2)) {//duplicados en la letra
                        //System.out.println("=========DUPLICADO" + sym1);
                        String concatenacion = hashAux.get(i).concat(hashAux.get(j));

// Separamos la cadena en un arreglo de cadenas utilizando la coma como separador
                        String[] numeros = concatenacion.split(",");

// Creamos un HashSet para almacenar los números únicos
                        Set<String> numerosUnicos = new HashSet<>();

// Recorremos el arreglo de números
                        for (String numero : numeros) {
                            // Agregamos cada número al HashSet
                            numerosUnicos.add(numero);
                        }

// Convertimos el HashSet de números únicos a una cadena separada por comas
                        String cadenaSinDuplicados = String.join(",", numerosUnicos);

// Imprimimos la cadena sin números duplicados
                        //System.out.println(cadenaSinDuplicados);

                        hashAux.compute(i, (key, val) -> cadenaSinDuplicados);
                        hashAux.compute(j, (key, val) -> "");

                    } else {
                    }
                }
            }
        }

        for (String i : hashAux.keySet()) { //buscar en hashEstados
            //System.out.println(i + "-> " + hashAux.get(i));
            boolean flag = false;
            if (hashAux.get(i).equals("")) {

            } else {

                String[] x = hashAux.get(i).split(",");
                Arrays.sort(x);
                String sigposOrdenado = "";
                for (String y : x) {
                    sigposOrdenado = sigposOrdenado + y + ",";
                }
                hashAux.replace(i, sigposOrdenado); //ordena las sigpos para buscar

                for (String j : hashEstados.keySet()) {//recorre hashEstados
                    if (hashAux.get(i).equals(j)) { //sigpos == sigpos, ya existe S
                        flag = true;
                    }
                }
                if (flag == true) {
                    // System.out.println("USAR ESTADO EXISTENTE S"+hashEstados.get(hashAux.get(i)));
                    System.out.println("S" + estadoEval + " " + arrayId.get(Integer.parseInt(i) - 1) + "->" + hashAux.get(i) + "=" + hashEstados.get(hashAux.get(i)));
                    ls.insertar("S"+estadoEval, arrayId.get(Integer.parseInt(i) - 1), hashAux.get(i), "S"+hashEstados.get(hashAux.get(i)));
                } else {
                    //System.out.println("CREAR ESTADO S"+numEstado+"->"+sigposOrdenado);
                    System.out.println(estadoEval + " " + arrayId.get(Integer.parseInt(i) - 1) + "->" + hashAux.get(i) + "=" + "S" + numEstado);
                    ls.insertar("S"+estadoEval, arrayId.get(Integer.parseInt(i) - 1), hashAux.get(i), "S" + numEstado);
                    hashEstados.put(hashAux.get(i), numEstado + "");
                    numEstado++;
                    sigposEvaluar.add(hashAux.get(i));
                }
            }

        }
        // System.out.println(hashEstados);
        //System.out.println(sigposEvaluar);
        if (!sigposEvaluar.isEmpty()) {
            // obtenemos el indice del ultimo elemento
            int lastIndex = sigposEvaluar.size() - 1;

            // obtenemos y eliminamos el ultimo elemento del ArrayList
            String ultimoElemento = sigposEvaluar.remove(lastIndex);

            // imprimimos el ultimo elemento
            //System.out.println("El ultimo elemento es: " + ultimoElemento +"S"+hashEstados.get(ultimoElemento));
            transiciones(ultimoElemento, Integer.parseInt(hashEstados.get(ultimoElemento)),nombre);
        } else {
            System.out.println("El ArrayList esta vacio.");
            System.out.println(hashEstados);
            arrayId.clear();
            sigposEvaluar.clear();
            hashEstados.clear();
            hashAux.clear();
            numEstado=0;
            tablaSiguientes.clear();
            numNodo=1;
            numHoja=1;
            ls.transicionesDot(nombre);
            ls.eliminar();
        }

    }
    //HASH TABLE SIGIENTES------------------------------------------------------
    public static HashMap<String, String> tablaSiguientes = new HashMap<String, String>();

    //METODO DEL ARBOL----------------------------------------------------------
    public static int numNodo = 1; //para gtraficar
    public static int numHoja = 1; //para identif. hojas 
    public static Nodo raiz;

    public static void graficarSiguientes(String nombre) {
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter(nombre + "_siguientes.dot");
            pw = new PrintWriter(fichero);
            String texto = """
                         digraph tabla {
                             node [shape=plaintext]
                             tabla [label=<<table border="1" cellspacing="0">
                                 <tr><td bgcolor="#ADD8E6"><b> Sym </b></td><td bgcolor="#ADD8E6"><b> Hoja </b></td><td bgcolor="#ADD8E6"><b> Siguientes </b></td></tr>
                                 
                         """;
            int contador = 0;
            for (String i : tablaSiguientes.keySet()) {
                texto += "<tr><td>" + arrayId.get(contador) + "</td><td>" + i + "</td><td>" + tablaSiguientes.get(i) + "</td></tr>";
                contador++;
            }
            texto += "</table>>];}";
            pw.println(texto);

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo" + e);
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = nombre + "_siguientes.dot";
            //dirección donde se creara la magen
            String fileOutputPath = "SIGUIENTES_202004796\\"+ nombre + "_siguientes.jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);
            System.out.println("######listo, Siguientes hecho###############");

            hashEstados.put(raiz.primero, numEstado + "");
            numEstado++;
            transiciones(raiz.primero, 0,nombre);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void graficarArbol(Nodo act, String nombre) {

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter(nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("rankdir=UD");
            pw.println("node[shape=ellipse]");
            pw.println("concentrate=true");
            pw.println(act.getCodigoInterno());

            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo" + e);
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "ARBOLES_202004796\\"+ nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);
            System.out.println("######listo, arbol hecho###############");

            numNodo = 1;
            numHoja = 1;
            graficarSiguientes(nombre);
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
        }
    }

    


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= INI EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // INI ::= CONTENIDO 
            {
              Object RESULT =null;
		System.out.println("listo");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("INI",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // CONTENIDO ::= llaveAbrir SENTENCIAS llaveCerrar 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONTENIDO",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // SENTENCIAS ::= SENTENCIAS CONJUNTOS 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // SENTENCIAS ::= SENTENCIAS comentario 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // SENTENCIAS ::= SENTENCIAS comentarioMult 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // SENTENCIAS ::= SENTENCIAS ER 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // SENTENCIAS ::= SENTENCIAS DELIMITADORES 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // SENTENCIAS ::= SENTENCIAS ENTRADA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // SENTENCIAS ::= SENTENCIAS error 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // SENTENCIAS ::= CONJUNTOS 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // SENTENCIAS ::= COMENTARIOS 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // SENTENCIAS ::= DELIMITADORES 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // SENTENCIAS ::= ENTRADA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // SENTENCIAS ::= comentario 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // SENTENCIAS ::= comentarioMult 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // CONJUNTOS ::= conj dosPuntos tld flecha notacion pComa 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJUNTOS",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ER ::= tld flecha NOTACIONER pComa 
            {
              Nodo RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                    //CENTINELA 
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    anulable=false;
                    primeros= parser.numHoja+",";
                    ultimos= parser.numHoja+",";
                    Nodo Centinela= new Nodo(null,null,"#",parser.numNodo,parser.numHoja,anulable,primeros,ultimos);
                    parser.numNodo++;

                    //AGREGAR CENTINELA
                    anulable=false;
                    if(a.isAnulable()==true){
                        primeros=a.getPrimero()+parser.numHoja;
                    }else{
                        primeros=a.getPrimero();
                    }
                    ultimos=parser.numHoja+"";
                    Nodo concatInicio = new Nodo(a,Centinela,".",parser.numNodo,0,anulable,primeros,ultimos);
                    

                    String[] val =a.getUltimo().split(",");
                    for (String x : val)
                        if(tablaSiguientes.containsKey(x)==true){
                            tablaSiguientes.computeIfPresent(x, (key1, val1) -> val1 + parser.numHoja+",");
                        }else{
                            tablaSiguientes.put(x,parser.numHoja+",");
                        }

                    tablaSiguientes.put(numHoja+"","");
                    parser.raiz=concatInicio;
                    arrayId.add("#");
                    graficarArbol(concatInicio,b);
                    
                  System.out.println("-------------------------------------------entra");
System.out.println(tablaSiguientes);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // NOTACIONER ::= punto NOTACIONER NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo b = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    if(a.isAnulable()==true && b.isAnulable()==true){
                        anulable=true;
                    }else{
                        anulable=false;
                    }
                    if(a.isAnulable()==true){
                        primeros=a.getPrimero()+b.getPrimero();
                    }else{
                        primeros=a.getPrimero();
                    }
                    if(b.isAnulable()==true){
                        ultimos=a.getUltimo()+b.getUltimo();
                    }else{
                        ultimos=b.getUltimo();
                    }
                    Nodo nuevaConcat = new Nodo(a,b,".",parser.numNodo,0,anulable,primeros,ultimos);
                    parser.numNodo++;
                    RESULT = nuevaConcat;
                    
                    String[] val =a.getUltimo().split(",");
                    for (String x : val)
                        if(tablaSiguientes.containsKey(x)==true){
                            tablaSiguientes.computeIfPresent(x, (key1, val1) -> val1 + b.getPrimero());
                        }else{
                            tablaSiguientes.put(x,b.getPrimero());
                        }
                        
                    
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // NOTACIONER ::= or NOTACIONER NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo b = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    if(a.isAnulable()==true || b.isAnulable()==true){
                        anulable=true;
                    }else{
                        anulable=false;
                    }
                    primeros= a.getPrimero()+b.getPrimero();
                    ultimos= a.getUltimo()+b.getUltimo();
                    Nodo nuevaDisyun = new Nodo(a,b,"|",parser.numNodo,0,anulable,primeros,ultimos);
                    parser.numNodo++;
                    RESULT = nuevaDisyun;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NOTACIONER ::= asterisco NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    anulable=true;
                    primeros= a.getPrimero();
                    ultimos= a.getUltimo();
                    Nodo nuevaAsterisco= new Nodo(a,null,"*",parser.numNodo,0,anulable,primeros,ultimos);
                    parser.numNodo++;
                    RESULT = nuevaAsterisco;

                    String[] val =a.getUltimo().split(",");
                    for (String x : val)
                        if(tablaSiguientes.containsKey(x)==true){
                            tablaSiguientes.computeIfPresent(x, (key1, val1) -> val1 + a.getPrimero());
                        }else{
                            tablaSiguientes.put(x,a.getPrimero());
                        }
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // NOTACIONER ::= suma NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    if(a.isAnulable()==true){
                        anulable=true;
                    }else{
                        anulable=false;
                    }
                    primeros= a.getPrimero();
                    ultimos= a.getUltimo();
                    Nodo nuevaSuma= new Nodo(a,null,"+",parser.numNodo,0,anulable,primeros,ultimos);
                    parser.numNodo++;
                    RESULT = nuevaSuma;

                    String[] val =a.getUltimo().split(",");
                    for (String x : val)
                        if(tablaSiguientes.containsKey(x)==true){
                            tablaSiguientes.computeIfPresent(x, (key1, val1) -> val1 + a.getPrimero());
                        }else{
                            tablaSiguientes.put(x,a.getPrimero());
                        }
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NOTACIONER ::= interrogacion NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    anulable=true;
                    primeros= a.getPrimero();
                    ultimos= a.getUltimo();
                    Nodo nuevaInterrogacion= new Nodo(a,null,"?",parser.numNodo,0,anulable,primeros,ultimos);
                    parser.numNodo++;
                    RESULT = nuevaInterrogacion;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // NOTACIONER ::= erComillas 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    anulable=false;
                    primeros= parser.numHoja+",";
                    ultimos= parser.numHoja+",";
                    Nodo nuevaHoja= new Nodo(null,null,a.replace("\"", ""),parser.numNodo,parser.numHoja,anulable,primeros,ultimos);
                    parser.numNodo++;
                    parser.numHoja++;
                    RESULT = nuevaHoja;
                    
                    arrayId.add(a.replace("\"", ""));
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // NOTACIONER ::= erLlaves 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    anulable=false;
                    primeros= parser.numHoja+",";
                    ultimos= parser.numHoja+",";
                    Nodo nuevaHoja1= new Nodo(null,null,a,parser.numNodo,parser.numHoja,anulable,primeros,ultimos);
                    parser.numNodo++;
                    parser.numHoja++;
                    RESULT = nuevaHoja1;
                    
                    arrayId.add(a);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // NOTACIONER ::= simboloEspecial 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    boolean anulable;
                    String primeros;
                    String ultimos;
                    anulable=false;
                    primeros= parser.numHoja+",";
                    ultimos= parser.numHoja+",";
                    Nodo nuevaHoja2= new Nodo(null,null,a,parser.numNodo,parser.numHoja,anulable,primeros,ultimos);
                    parser.numNodo++;
                    parser.numHoja++;
                    RESULT = nuevaHoja2;

                    arrayId.add(a);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // DELIMITADORES ::= porcentaje porcentaje 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("DELIMITADORES",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // ENTRADA ::= tld dosPuntos lexemaEntrada pComa 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ENTRADA",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
